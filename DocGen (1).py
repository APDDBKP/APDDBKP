#Импорт основных модулей
import os
import docxtpl
import pandas as pd

#Импорт функций модуля tkinter
from tkinter import *
from tkinter import messagebox #для дальнейшего вызова диалоговых окон
from tkinter.filedialog import askopenfilename #для интерактивного выбора исходных файлов пользователем

#Игнорирование предупреждений от модуля pandas (чтобы не мешались в консольном выводе)
import warnings
warnings.simplefilter(action='ignore', category=FutureWarning)

#Переход в директорию, в которой находится запускаемый файл
os.chdir(os.path.dirname(__file__))

#Конструкция try-except пытается сперва выполнить блок кода внутри try, а в случае неудачи переходит в блок except
try:
    #Выбор исходного файла с табличными данными формата CSV или XLSX и запись его в переменную data
    data = askopenfilename(title='Выберите файл формата XLSX или CSV с данными студентов',
                        filetypes=[('Excel/CSV files', ['xlsx', 'csv'])])
        #Попытка обработать выбранный файл как Excel-файл (ключ header со значением None означает, что в данном случае рассматривается таблица, в которой нет строки-заголовка)
    try:
        data = pd.read_excel(data, header=None)
        #В случае неудачи происходит обработка файла как CSV (также без строки-заголовка), в котором разделителем полей выступает точка с запятой
    except:
        data = pd.read_csv(data, delimiter=';', header=None) #В обоих случаях идёт запись таблицы в объект DataFrame модуля pandas (сокращённо pd) - таблица, хранимая во временной памяти, с которой будет осуществляться работа далее

    #Выбор исходного файла с шаблоном документа формата DOCX (заполняемые поля в котором обозначены как ключевые слова, заключенные в двойные фигурные скобки)
    doc = askopenfilename(title='Выберите файл шаблона DOCX', filetypes=[('Microsoft Word files', ['docx'])])
        #Выход из блока try в случае, если файл не был выбран (при этом возвращается пустое имя в переменной doc)
    if doc == '':
        exit() #В силу механики работы try-except, в данном случае команда exit() не завершит выполнение программы, а только переключит её из блока try в except
        
        #Создание объекта шаблона через модуль docxtpl, в качестве исходных данных берется выбранный выше DOCX-файл
    doc = docxtpl.DocxTemplate(doc)

#В случае, если что-то пошло не так в блоке try выше, выводится диалоговое окно с уведомлением об ошибке, и программа преждевременно завершает свою работу
except:
    messagebox.showerror('ОШИБКА!', 'Некорректный выбор исходных файлов.')
    exit() #Выход из программы

#Создание и переход в директорию, в которой будут сохранены сгенерированные документы
os.mkdir('Заявления на ВКР')
os.chdir('Заявления на ВКР')

#Проход в цикле по всем строкам таблицы с исходными данными
for i, row in data.iterrows():

    #Блок try-except, см. выше
    try:
        #Запись ФИО студента в родительном падеже, которая находится в третьем поле строки (row), в переменную stud_creds_init_1.
        #Так как нумерация полей начинается с нуля, третье поле имеет индекс 2, поэтому его идентификатор - row[2]. Далее аналогично выделяются другие поля из текущей строки
        stud_creds_init_1 = row[2]

        #Запись ФИО студента в именительном падеже (шестое поле/столбец) в переменную stud_creds_init_2. Так как в таблице ФИО указано полностью, а в документе необходим формат "инициалы+фамилия",
            #то сперва функцией split ФИО разбивается по разделителю ' ' (пробел, указано в скобках) на три слова, и эти три слова в виде списка записываются во временную переменную temp,
        temp = row[5].split(' ')
            #после чего сокращаем имя и отчество до первых букв расставляем и слова в нужном порядке. 
                #"f" перед кавычками необходима, чтобы внутрь строки string (внутри одиночных кавычек) можно было вставлять переменные через фигурные скобки
                #конструкция формата temp[1][0] означает, что из списка temp (три слова - фамилия, имя отчество, в данном случае) берется второе слово ([1] - так как начинаем с нулевого индекса) и у этого слова берется первая буква (аналогично [0], так как отсчет идет с нуля)
                #аналогично с первой буквой отчества и отчеством в конце этой строки. В итоге получается, например, из Иванов Иван Иванович -> И.И. Иванов
        stud_creds_init_2 = f'{temp[1][0]}.{temp[2][0]}. {temp[0]}'

        #Аналогично случаю выше. ФИО научрука.
        adviser_creds_init_1 =  row[4]

        #Аналогично случаю выше ФИО научрука переводится в инициалы, научная степень и должность остаются без изменений.
            #Функция partition схожа с функцией split, но partition разделяет строку по разделителю так, что получается 3 элемента:
                #[0] - то, что до разделителя, [1] - сам разделитель, [2] - то, что после разделителя
        temp = row[4].partition(',')[0].split(' ')
        adviser_creds_init_2 = f'{temp[1][0]}.{temp[2][0]}. {temp[0]},{row[4].partition(',')[2]}'

        temp = row[7].partition(',')[0].split(' ')
        chair_head_creds =  f'{temp[1][0]}.{temp[2][0]}. {temp[0]},{row[4].partition(',')[2]}'

        #Запись всех необходимых переменных в словарь формата "ключевое слово в DOCX : значение из таблицы, на которое его нужно заменить"
        context = {
                'group_num': row[0],
                'speciality': row[1],
                'stud_creds_init_1': stud_creds_init_1,
                'work_title': f'«{row[3]}»',
                'adviser_creds_init_1': adviser_creds_init_1,
                'stud_creds_init_2': stud_creds_init_2,
                'adviser_creds_init_2': adviser_creds_init_2,
                'chair_head_creds': chair_head_creds
                }
        
        #Заполнение документа данными из текущей строки
        doc.render(context)
        #Сохранение документа
        doc.save(f'{i+1}. Заявление_на_ВКР_{row[0]}_{row[5]}.docx')

    #Аналогично блоку except выше
    except:
        messagebox.showerror('ОШИБКА!', f'Произошли неполадки в процессе обработки строки {i}:\n\n{row[5]}, {row[0]}.')
        exit()

#Вывод диалогового окна об успешной отработке программы
messagebox.showinfo('УСПЕХ!', 'Документы успешно сгенерированы.')